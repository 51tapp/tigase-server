[[cil7]]
= Component Implementation - Lesson 7 - Data Repository
:author: not known
:version: v1.0 initial release
:date: 2015-07-27 16:19

== ConfigRepository
There are cases when you want to store some data permanently by your component. You can of course use the component configuration to provide some database connection settings, implement your own database connector and store records you need. There is, however, a very simple and useful framework which allows you to read and store some data transparently in either a database or a disk file. The framework also supports ad-hoc command interface straight away so you can manipulate your component data using an XMPP client.

In order to use it one needs to extend +tigase.db.comp.ConfigRepository+ abstract class.

== Accessing UserRepository or AuthRepository
To use *AuthRepository* or *UserRepository* you need only to declare fields properly and annotated them with *@Inject*. This fields must be part of a class managed by Tigase Kernel - class of a component or any class annotated with *@Bean* annotation.
For that classes proper instances of repositories will be injected by dependency injection.

.Example usage of AuthRepository and UserRepository
[source,java]
----
@Inject
private AuthRepository authRepository;
@Inject
private UserRepository userRepository;
----

== Accessing other repositories
In order to have more freedom while accessing repositories it's possible to create and use custom repository implementation which implements *DataSourceAware* interface.

For our example let's assume it will be class implementing *TestRepositoryIfc* and our implementation will be using JDBC.
To make it work, we need to define +TestRepositoryIfc+ as a generic interface extending +DataSourceAware+ interface.
+DataSourceAware+ interface will provide definition for methods required by Tigase XMPP Server internals to initialize custom repository classes based on +TestRepositoryIfc+.

.TestRepositoryIfc
[source,java]
----
public interface TestRepositoryIfc<DS extends DataSource> extends DataSourceAware<DS> {
  // Example method
  void addItem(BareJID userJid, String item) throws RepositoryException;
}
----

Next we need to prepare our actual implementation of repository - class responsible for execution of SQL statements. In this class we need to implement all of methods from our interface
and method *void setDataSource(DataSource dataSource)* which comes from *DataSourceAware* interface. In this method we need to initialize data source, ie. create prepared statements.
We should annotate our new class with +@Repository.Meta+ annotation which will allow Tigase XMPP Server to find this class whenever class implementing +TestRepositoryIfc+ and with support for data source with jdbc URI.

[source,java]
----
@Repository.Meta(supportedUris = "jdbc:.*")
public static class JDBCTestRepository implements TestRepositoryIfc<DataRepository> {

  private static final String SOME_STATEMENT = "select * from tig_users";

  private DataRepository repository;

  @Override
  public void setDataSource(DataRepository repository) {
    // here we need to initialize required prepared statements
    try {
      repository.initPreparedStatement(SOME_STATEMENT, SOME_STATEMENT);
    } catch (SQLException ex) {
      throw new RuntimeException("Could not initialize repository", ex);
    }
    this.repository = repository;
  }

  @Override
  public void addItem(BareJID userJid, String item) throws RepositoryException {
    try {
      PreparedStatement stmt = repository.getPreparedStatement(userJid, SOME_STATEMENT);
      synchronized (stmt) {
        // do what needs to be done
      }
    } catch (SQLException ex) {
      throw new RepositoryException(ex);
    }
  }
}
----

As you can see we defined type of a data source generic parameter for interface +TestRepositoryIfc+. With that we make sure that only instance implementing +DataRepository+ interface will be provided and thanks to that we do not need to cast provided instance of +DataSource+ to this interface before any access to data source.

With that in place we need to create class which will take care of adding support for multi-database setup. In our case it will be *TestRepositoryMDBean*, which will take care of discovery of repository class, initialization and reinjection of data source.
It is required to do so, as it was just mentioned our +TestRepositoryMDBean+ will be responsible for initialization of +JDBCTestRepository+ (actually this will be done by +MDRepositoryBean+ which is extended by +TestRepositoryMDBean+.

[source,java]
----
@Bean(name = "repository", parent = TestComponent.class, active = true)
public static class TestRepositoryMDBean extends MDRepositoryBeanWithStatistics<TestRepositoryIfc>
    implements TestRepositoryIfc {

  public TestRepositoryMDBean() {
    super(TestRepositoryIfc.class);
  }

  @Override
  public Class<?> getDefaultBeanClass() {
    return TestRepositoryConfigBean.class;
  }

  @Override
  public void setDataSource(DataSource dataSource) {
    // nothing to do here
  }

  @Override
  public void addItem(BareJID userJid, String item) throws RepositoryException {
    getRepository(userJid.getDomain()).addItem(userJid, item);
  }

  @Override
  protected Class<? extends TestRepositoryIfc> findClassForDataSource(DataSource dataSource)
				throws DBInitException {
    return DataSourceHelper.getDefaultClass(TestRepositoryIfc.class, dataSource.getResourceUri());
  }

  public static class TestRepositoryConfigBean extends MDRepositoryConfigBean<TestRepositoryIfc> {
  }
}
----

Most of this code will be the same in all implementations based on MDRepositoryBeanWithStatistics. In our case only custom method is *void addItem(...)* which uses *getRepository(String domain)* method to retrieve correct repository for a domain.
This retrieval of actual repository instance for a domain will need to be done for every custom method of +TestRepositoryIfc+/

While this is more difficult to implement than in previous version, it gives you support for multi database setup and provides you with statistics of database query times which may be used for diagnosis.

As you can also see, we've annotated *TestRepositoryMDBean* with *@Bean* annotation which will force Tigase Kernel to load it every time *TestComponent* will be loaded. This way it is possible to inject instance of this class as a dependency to any bean used by this component (ie. component, module, etc.) by just creating a field and annotating it:

[source,java]
----
@Inject
private TestRepositoryIfc testRepository;
----

TIP: In *testRepository* field instance of *TestRepositoryMDBean* will be injected.

